<application>
  <component name="AppStorage">
    <histories>
      <item value="unmetered" />
      <item value="NET CAPABILITY NOT METERED" />
      <item value="METERED" />
      <item value="INTERNET" />
      <item value="* Indicates this network uses a Cellular transport." />
      <item value="TRANSPORT CELLULAR" />
      <item value="NET_CAPABILITY_MMS, NET_CAPABILITY_SUPL, NET_CAPABILITY_DUN, NET_CAPABILITY_FOTA, NET_CAPABILITY_IMS, NET_CAPABILITY_CBS, NET_CAPABILITY_WIFI_P2P, NET_CAPABILITY_IA, NET_CAPABILITY_RCS, NET_CAPABILITY_XCAP, NET_CAPABILITY_EIMS, NET_CAPABILITY_NOT_METERED, NET_CAPABILITY_INTERNET, NET_CAPABILITY_NOT_RESTRICTED, NET_CAPABILITY_TRUSTED, NET_CAPABILITY_NOT_VPN, NET_CAPABILITY_VALIDATED, NET_CAPABILITY_CAPTIVE_PORTAL, NET_CAPABILITY_NOT_ROAMING, NET_CAPABILITY_FOREGROUND, NET_CAPABILITY_NOT_CONGESTED, NET_CAPABILITY_NOT_SUSPENDED, NET_CAPABILITY_OEM_PAID," />
      <item value="* * Tells the underlying networking system that the caller wants to * begin using the named feature. The interpretation of {@code feature} * is completely up to each networking implementation. *" />
      <item value="/** * Binds the current process to {@code network}. All Sockets created in the future * (and not explicitly bound via a bound SocketFactory from * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to * {@code network}. All host name resolutions will be limited to {@code network} as well. * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to * work and all host name resolutions will fail. This is by design so an application doesn't * accidentally use Sockets it thinks are still bound to a particular {@link Network}. * To clear binding pass {@code null} for {@code network}. Using individually bound * Sockets created by Network.getSocketFactory().createSocket() and * performing network-specific host name resolutions via * {@link Network#getAllByName Network.getAllByName} is preferred to calling * {@code setProcessDefaultNetwork}. * * @param network The {@link Network} to bind the current process to, or {@code null} to clear * the current binding. * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid. * @deprecated This function can throw {@link IllegalStateException}. Use * {@link #bindProcessToNetwork} instead. {@code bindProcessToNetwork} * is a direct replacement." />
      <item value="reply" />
      <item value="scrap Or Recycle View" />
      <item value="other views that were previously recycled." />
      <item value="This ViewHolder should not be recycled. This flag is set via setIsRecyclable() * and is intended to keep views around during animations." />
      <item value="This ViewHolder points at data that represents an item previously removed from the * data set. Its view may still be used for things like outgoing animations. */" />
      <item value="This ViewHolder's data is invalid. The identity implied by mPosition and mItemId * are not to be trusted and may no longer match the item view type. * This ViewHolder must be fully rebound to different data." />
      <item value="The data this ViewHolder's view reflects is stale and needs to be rebound * by the adapter. mPosition and mItemId are consistent." />
      <item value="This ViewHolder has been bound to a position; mPosition, mItemId and mItemViewType * are all valid. */" />
      <item value="/ This is very ugly but the only place we can grab this information // before the View is rebound and returned to the LayoutManager for post layout ops. // We don't need this in pre-layout since the VH is not updated by the LM." />
      <item value="try Get View Holder For Position By Deadline" />
      <item value="Returns the value of the given calendar field. In lenient mode, * all calendar fields are normalized. In non-lenient mode, all * calendar fields are validated and this method throws an * exception if any calendar fields have out-of-range values. The * normalization and validation are handled by the * {@link #complete()} method, which process is calendar * system dependent." />
      <item value="merge" />
      <item value="Left edge, with item decoration insets included" />
      <item value="Lay out the given child view within the RecyclerView using coordinates that * include any current {@link ItemDecoration ItemDecorations}. *" />
      <item value="&gt;LayoutManagers should prefer working in sizes and coordinates that include * item decoration insets whenever possible. This allows the LayoutManager to effectively * ignore decoration insets within measurement and layout code. See the following * methods:&lt;/p&gt;" />
      <item value="// we need i to calculate the real offset of current view" />
      <item value="Temporarily detach and scrap all currently attached child views. Views will be scrapped * into the given Recycler. The Recycler may prefer to reuse scrap views before * other views that were previously recycled." />
      <item value="Returns the space occupied by this View in the perpendicular orientation including * decorations and margins. *" />
      <item value="m Decorated Measurement In Other" />
      <item value="* The offset of property which will change while scrolling" />
      <item value="//make sure properties are correct while measure more than once" />
      <item value="get Decorated Measured Height" />
      <item value="dry Run" />
      <item value="The Recycler may reuse a scrap or detached view from a shared pool if one is * available for the correct view type. If the adapter has not indicated that the * data at the given position has changed, the Recycler will attempt to hand back * a scrap view that was previously initialized for that data without rebinding." />
      <item value="This method should be used by {@link LayoutManager} implementations to obtain * views to represent data from an {@link Adapter}." />
      <item value="* Obtain a view initialized for the given position." />
      <item value="ensure Layout State" />
      <item value="fixed the wrap_content height of item_order by using a ScrollView to wrapper item_order" />
      <item value="using a ScrollView to wrapper item_order" />
      <item value="scrap" />
      <item value="set Item Prefetch Enabled" />
      <item value="reverse Layout" />
      <item value="RecyclerView internally does its own View measurement caching which should help with * WRAP_CONTENT. * &lt;p&gt; * Use this method if the View is not yet measured and you need to decide whether to * measure this View or not." />
      <item value="The measured height of this view. May be a complex * bit mask as defined by {@link #MEASURED_SIZE_MASK} and * {@link #MEASURED_STATE_TOO_SMALL}. */" />
      <item value="calling LayoutManager here is not pretty but that API is already public and it is better // than creating another method since this is internal." />
      <item value="This specific call should be considered deprecated and replaced with * {@link #defaultOnMeasure(int, int)}. It can't actually be replaced as it could * break existing third party code but all documentation directs developers to not * override {@link LayoutManager#onMeasure(int, int)} when * {@link LayoutManager#isAutoMeasureEnabled()} returns true. */" />
      <item value="If your use of RecyclerView falls into this category, set this to {@code true}. It will allow * RecyclerView to avoid invalidating the whole layout when its adapter contents change. *" />
      <item value="RecyclerView can perform several optimizations if it can know in advance that RecyclerView's * size is not affected by the adapter contents. RecyclerView can still change its size based * on other factors (e.g. its parent's size) but this size calculation cannot depend on the * size of its children or contents of its adapter (except the number of items in the adapter)." />
      <item value="Implementors of LayoutManager should define whether or not it uses * AutoMeasure by overriding {@link #isAutoMeasureEnabled()}. */" />
      <item value="if layout measurement should be done by the * RecyclerView, &lt;code&gt;false&lt;/code&gt; if it should be done by this * LayoutManager." />
      <item value="Defines whether the measuring pass of layout should use the AutoMeasure mechanism of * {@link RecyclerView} or if it should be done by the LayoutManager's implementation of * {@link LayoutManager#onMeasure(Recycler, State, int, int)}. *" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="60" />
        <entry key="ENGLISH" value="61" />
        <entry key="ROMANIAN" value="1" />
      </map>
    </option>
  </component>
</application>