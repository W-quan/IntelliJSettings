<application>
  <component name="AppStorage">
    <histories>
      <item value="/ This is very ugly but the only place we can grab this information // before the View is rebound and returned to the LayoutManager for post layout ops. // We don't need this in pre-layout since the VH is not updated by the LM." />
      <item value="try Get View Holder For Position By Deadline" />
      <item value="Returns the value of the given calendar field. In lenient mode, * all calendar fields are normalized. In non-lenient mode, all * calendar fields are validated and this method throws an * exception if any calendar fields have out-of-range values. The * normalization and validation are handled by the * {@link #complete()} method, which process is calendar * system dependent." />
      <item value="merge" />
      <item value="Left edge, with item decoration insets included" />
      <item value="Lay out the given child view within the RecyclerView using coordinates that * include any current {@link ItemDecoration ItemDecorations}. *" />
      <item value="&gt;LayoutManagers should prefer working in sizes and coordinates that include * item decoration insets whenever possible. This allows the LayoutManager to effectively * ignore decoration insets within measurement and layout code. See the following * methods:&lt;/p&gt;" />
      <item value="// we need i to calculate the real offset of current view" />
      <item value="Temporarily detach and scrap all currently attached child views. Views will be scrapped * into the given Recycler. The Recycler may prefer to reuse scrap views before * other views that were previously recycled." />
      <item value="Returns the space occupied by this View in the perpendicular orientation including * decorations and margins. *" />
      <item value="m Decorated Measurement In Other" />
      <item value="* The offset of property which will change while scrolling" />
      <item value="//make sure properties are correct while measure more than once" />
      <item value="get Decorated Measured Height" />
      <item value="dry Run" />
      <item value="The Recycler may reuse a scrap or detached view from a shared pool if one is * available for the correct view type. If the adapter has not indicated that the * data at the given position has changed, the Recycler will attempt to hand back * a scrap view that was previously initialized for that data without rebinding." />
      <item value="This method should be used by {@link LayoutManager} implementations to obtain * views to represent data from an {@link Adapter}." />
      <item value="* Obtain a view initialized for the given position." />
      <item value="ensure Layout State" />
      <item value="fixed the wrap_content height of item_order by using a ScrollView to wrapper item_order" />
      <item value="using a ScrollView to wrapper item_order" />
      <item value="scrap" />
      <item value="set Item Prefetch Enabled" />
      <item value="reverse Layout" />
      <item value="RecyclerView internally does its own View measurement caching which should help with * WRAP_CONTENT. * &lt;p&gt; * Use this method if the View is not yet measured and you need to decide whether to * measure this View or not." />
      <item value="The measured height of this view. May be a complex * bit mask as defined by {@link #MEASURED_SIZE_MASK} and * {@link #MEASURED_STATE_TOO_SMALL}. */" />
      <item value="calling LayoutManager here is not pretty but that API is already public and it is better // than creating another method since this is internal." />
      <item value="This specific call should be considered deprecated and replaced with * {@link #defaultOnMeasure(int, int)}. It can't actually be replaced as it could * break existing third party code but all documentation directs developers to not * override {@link LayoutManager#onMeasure(int, int)} when * {@link LayoutManager#isAutoMeasureEnabled()} returns true. */" />
      <item value="If your use of RecyclerView falls into this category, set this to {@code true}. It will allow * RecyclerView to avoid invalidating the whole layout when its adapter contents change. *" />
      <item value="RecyclerView can perform several optimizations if it can know in advance that RecyclerView's * size is not affected by the adapter contents. RecyclerView can still change its size based * on other factors (e.g. its parent's size) but this size calculation cannot depend on the * size of its children or contents of its adapter (except the number of items in the adapter)." />
      <item value="Implementors of LayoutManager should define whether or not it uses * AutoMeasure by overriding {@link #isAutoMeasureEnabled()}. */" />
      <item value="if layout measurement should be done by the * RecyclerView, &lt;code&gt;false&lt;/code&gt; if it should be done by this * LayoutManager." />
      <item value="Defines whether the measuring pass of layout should use the AutoMeasure mechanism of * {@link RecyclerView} or if it should be done by the LayoutManager's implementation of * {@link LayoutManager#onMeasure(Recycler, State, int, int)}. *" />
      <item value="This method returns false by default (it actually returns the value passed to the * deprecated {@link #setAutoMeasureEnabled(boolean)}) and should be overridden to return * true if a LayoutManager wants to be auto measured by the RecyclerView." />
      <item value="Returns whether the measuring pass of layout should use the AutoMeasure mechanism of * {@link RecyclerView} or if it should be done by the LayoutManager's implementation of * {@link LayoutManager#onMeasure(Recycler, State, int, int)}." />
      <item value="The default implementation will handle EXACTLY measurements and respect * the minimum width and height properties of the host RecyclerView if measured * as UNSPECIFIED. AT_MOST measurements will be treated as EXACTLY and the RecyclerView * will consume all available space." />
      <item value="It is strongly advised to use the AutoMeasure mechanism by overriding * {@link #isAutoMeasureEnabled()} to return true as AutoMeasure handles all the standard * measure cases including when the RecyclerView's layout_width or layout_height have been * set to wrap_content. If {@link #isAutoMeasureEnabled()} is overridden to return true, * this method should not be overridden." />
      <item value="This method must be called by {@link #onMeasure(int, int)} to store the * measured width and measured height. Failing to do so will trigger an * exception at measurement time." />
      <item value="m Layout Frozen" />
      <item value="m Intercept Request Layout Depth" />
      <item value="If your use of RecyclerView falls into this category, set this to {@code true}. It will allow * RecyclerView to avoid invalidating the whole layout when its adapter contents change. * * @param hasFixedSize true if adapter changes cannot affect the size of the RecyclerView. */" />
      <item value="with Cross Fade" />
      <item value="enables a cross fade animation" />
      <item value="filter" />
      <item value="Appedner Mode Async" />
      <item value="don't show order if don't have location" />
      <item value="don't show order if no location" />
      <item value="ยก" />
      <item value="request api when open quick_settings every time." />
      <item value="INSTALL FAILED CONFLICTING PROVIDER" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="45" />
        <entry key="ENGLISH" value="46" />
        <entry key="ROMANIAN" value="1" />
      </map>
    </option>
  </component>
</application>