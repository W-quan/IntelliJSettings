<application>
  <component name="AppStorage">
    <histories>
      <item value="/* synchronized Surfaces accessed by an other thread from JNI */" />
      <item value="Facilities for retrieving external libraries and building them for systems that don't have the right versions." />
      <item value="doc/ - Miscellaneous documentation." />
      <item value="Main structure representing an input thread. This structure is mostly * private. The only public fields are read-only and constant." />
      <item value="We don't want a high input priority here or we'll * end-up sucking up all the CPU time */" />
      <item value="* reads the stream, cleans up and waits" />
      <item value="* This is the &quot;normal&quot; thread that spawns the input processing chain," />
      <item value="/* Set the destructor when we are sure we are initialized */" />
      <item value="* if we are preparsing, use the i_preparse_depth of the parent item */" />
      <item value="Retain" />
      <item value="The policy here is to ignore that we were created using a different * libvlc_instance, because we don't really care *" />
      <item value="* If needed, this waits for any other thread to release it." />
      <item value="Acquires a mutex." />
      <item value="Prevent gradle from building native code with ndk; we have our own Makefile for it." />
      <item value="A slave is an external input source that may contains an additional subtitle * track (like a .srt) or an additional audio track (like a .ac3). *" />
      <item value="Add a slave to the current media." />
      <item value="Returns the int descriptor. It's highly unlikely you should be calling this. Please discuss * your needs with a libcore maintainer before using this method. * @hide internal use only" />
      <item value="Instances of the file descriptor class serve as an opaque handle * to the underlying machine-specific structure representing an open * file, an open socket, or another source or sink of bytes. The * main practical use for a file descriptor is to create a * &lt;code&gt;FileInputStream&lt;/code&gt; or &lt;code&gt;FileOutputStream&lt;/code&gt; to * contain it." />
      <item value="* Adds the given transport type to this {@code NetworkCapability} instance. * Multiple transports may be applied sequentially. Note that when searching * for a network to satisfy a request, any listed in the request will satisfy the request. * For example {@code TRANSPORT_WIFI} and {@code TRANSPORT_ETHERNET} added to a * {@code NetworkCapabilities} would cause either a Wi-Fi network or an Ethernet network * to be selected. This is logically different than * {@code NetworkCapabilities.NET_CAPABILITY_*} listed above. *" />
      <item value="* Adds the given transport requirement to this builder. These represent * the set of allowed transports for the request. Only networks using one * of these transports will satisfy the request. If no particular transports * are required, none should be specified here. See {@link NetworkCapabilities} * for {@code TRANSPORT_*} definitions. *" />
      <item value="Indicates that this network is available for general use. If this is not set * applications should not attempt to communicate on this network. Note that this * is simply informative and not enforcement - enforcement is handled via other means. * Set by default." />
      <item value="NET CAPABILITY NOT RESTRICTED" />
      <item value="Indicates this is a network that has the ability to reach a Wi-Fi direct * peer." />
      <item value="Similarly if an application * needs an unmetered network for a bulk transfer it can specify that rather than assuming * all cellular based connections are metered and all Wi-Fi based connections are not. */" />
      <item value="Rather than indicate a need for Wi-Fi because an application * needs high bandwidth and risk obsolescence when a new, fast network appears (like LTE), * the application should specify it needs high bandwidth." />
      <item value="Rather than indicate a need for" />
      <item value="Rather than indicate a need for Wi-Fi because an application * needs high bandwidth and risk obsolescence when a new, f" />
      <item value="satisfy" />
      <item value="represent" />
      <item value="capability" />
      <item value="* Indicates that this network should be able to reach the internet." />
      <item value="SPIN INDETERMINATE" />
      <item value="is Satation" />
      <item value="accidentally" />
      <item value="unmetered" />
      <item value="NET CAPABILITY NOT METERED" />
      <item value="METERED" />
      <item value="INTERNET" />
      <item value="* Indicates this network uses a Cellular transport." />
      <item value="TRANSPORT CELLULAR" />
      <item value="NET_CAPABILITY_MMS, NET_CAPABILITY_SUPL, NET_CAPABILITY_DUN, NET_CAPABILITY_FOTA, NET_CAPABILITY_IMS, NET_CAPABILITY_CBS, NET_CAPABILITY_WIFI_P2P, NET_CAPABILITY_IA, NET_CAPABILITY_RCS, NET_CAPABILITY_XCAP, NET_CAPABILITY_EIMS, NET_CAPABILITY_NOT_METERED, NET_CAPABILITY_INTERNET, NET_CAPABILITY_NOT_RESTRICTED, NET_CAPABILITY_TRUSTED, NET_CAPABILITY_NOT_VPN, NET_CAPABILITY_VALIDATED, NET_CAPABILITY_CAPTIVE_PORTAL, NET_CAPABILITY_NOT_ROAMING, NET_CAPABILITY_FOREGROUND, NET_CAPABILITY_NOT_CONGESTED, NET_CAPABILITY_NOT_SUSPENDED, NET_CAPABILITY_OEM_PAID," />
      <item value="* * Tells the underlying networking system that the caller wants to * begin using the named feature. The interpretation of {@code feature} * is completely up to each networking implementation. *" />
      <item value="/** * Binds the current process to {@code network}. All Sockets created in the future * (and not explicitly bound via a bound SocketFactory from * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to * {@code network}. All host name resolutions will be limited to {@code network} as well. * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to * work and all host name resolutions will fail. This is by design so an application doesn't * accidentally use Sockets it thinks are still bound to a particular {@link Network}. * To clear binding pass {@code null} for {@code network}. Using individually bound * Sockets created by Network.getSocketFactory().createSocket() and * performing network-specific host name resolutions via * {@link Network#getAllByName Network.getAllByName} is preferred to calling * {@code setProcessDefaultNetwork}. * * @param network The {@link Network} to bind the current process to, or {@code null} to clear * the current binding. * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid. * @deprecated This function can throw {@link IllegalStateException}. Use * {@link #bindProcessToNetwork} instead. {@code bindProcessToNetwork} * is a direct replacement." />
      <item value="reply" />
      <item value="scrap Or Recycle View" />
      <item value="other views that were previously recycled." />
      <item value="This ViewHolder should not be recycled. This flag is set via setIsRecyclable() * and is intended to keep views around during animations." />
      <item value="This ViewHolder points at data that represents an item previously removed from the * data set. Its view may still be used for things like outgoing animations. */" />
      <item value="This ViewHolder's data is invalid. The identity implied by mPosition and mItemId * are not to be trusted and may no longer match the item view type. * This ViewHolder must be fully rebound to different data." />
      <item value="The data this ViewHolder's view reflects is stale and needs to be rebound * by the adapter. mPosition and mItemId are consistent." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="94" />
        <entry key="ENGLISH" value="95" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MARATHI" value="1" />
      </map>
    </option>
  </component>
</application>