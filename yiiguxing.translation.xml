<application>
  <component name="AppStorage">
    <histories>
      <item value="// BitmapFactory.Options out* variables are reset by most calls to decodeStream, successful or // otherwise, so capture here in case we log below." />
      <item value="// Once we've read the image header, we no longer need to allow the buffer to expand in // size. To avoid unnecessary allocations reading image data, we fix the mark limit so that it // is no larger than our current buffer size here. We need to do so immediately before // decoding the full image to avoid having our mark limit overridden by other calls to // mark and reset. See issue #225." />
      <item value="// If we failed to obtain the image dimensions, we may end up with an incorrectly sized Bitmap, // so we want to use a mutable Bitmap type. One way this can happen is if the image header is so // large (10mb+) that our attempt to use inJustDecodeBounds fails and we're forced to decode the // full size image." />
      <item value="* Checks to see whether or not a log for the specified tag is loggable at the specified level." />
      <item value="/** We want to switch from the disk cache service to the source executor. */" />
      <item value="INITIALIZE" />
      <item value="// When we're encoding we've already notified our callback and it isn't safe to do so again." />
      <item value="* Tries to intelligently choose a strategy based on the data source of the {@link" />
      <item value="/** Writes resources to disk after they've been decoded. */" />
      <item value="/** Writes retrieved data directly to the disk cache before it's decoded. */" />
      <item value="* &lt;p&gt;This value will not change over the lifetime of a Bitmap.&lt;/p&gt;" />
      <item value="* &lt;p&gt;This can be larger than the result of {@link #getByteCount()} if a bitmap is reused to * decode other bitmaps of smaller size, or by manual reconfiguration. See {@link * #reconfigure(int, int, Config)}, {@link #setWidth(int)}, {@link #setHeight(int)}, {@link * #setConfig(Bitmap.Config)}, and {@link BitmapFactory.Options#inBitmap * BitmapFactory.Options.inBitmap}. If a bitmap is not modified in this way, this value will be * the same as that returned by {@link #getByteCount()}.&lt;/p&gt; *" />
      <item value="* Returns the size of the allocated memory used to store this bitmap's pixels." />
      <item value="* &lt;p&gt;As of {@link android.os.Build.VERSION_CODES#KITKAT}, the result of this method can * no longer be used to determine memory usage of a bitmap. See {@link" />
      <item value="* Returns the minimum number of bytes that can be used to store this bitmap's pixels." />
      <item value="* Return the number of bytes between rows in the bitmap's pixels. Note that * this refers to the pixels as stored natively by the bitmap. If you call * getPixels() or setPixels(), then the pixels are uniformly treated as * 32bit values, packed according to the Color class." />
      <item value="* Used internally to set the containing binding for an included binding to this." />
      <item value="SHELF" />
      <item value="seek" />
      <item value="* If the View occupies multiple spans, span with the minimum index is returned." />
      <item value="If" />
      <item value="* Starting with RecyclerView &lt;b&gt;24.2.0&lt;/b&gt;, span indices are always indexed from position 0 * even if the layout is RTL. In a vertical GridLayoutManager, &lt;b&gt;leftmost&lt;/b&gt; span is span * 0 if the layout is &lt;b&gt;LTR&lt;/b&gt; and &lt;b&gt;rightmost&lt;/b&gt; span is span 0 if the layout is * &lt;b&gt;RTL&lt;/b&gt;. Prior to 24.2.0, it was the opposite which was conflicting with * {@link SpanSizeLookup#getSpanIndex(int, int)}." />
      <item value="useless" />
      <item value="opt" />
      <item value="Sweep angle (in degrees) measured clockwise" />
      <item value="* @param oval The bounds of oval defining shape and size of the arc" />
      <item value="* Append the specified arc to the path as a new contour. If the start of * the path is different from the path's current last point, then an * automatic lineTo() is added to connect the current contour to the * start of the arc. However, if the path is empty, then we call moveTo() * with the first point of the arc." />
      <item value="* Add the specified arc to the path as a new contour." />
      <item value="rectangle" />
      <item value="* Clear any lines and curves from the path, making it empty. * This does NOT change the fill-type setting." />
      <item value="* Add a closed round-rectangle contour to the path. Each corner receives * two radius values [X, Y]. The corners are ordered top-left, top-right, * bottom-right, bottom-left" />
      <item value="UNSHELVE" />
      <item value="time Ms" />
      <item value="tv desc" />
      <item value="空空如也" />
      <item value="repeat" />
      <item value="* Draw marquee text as ellipsize end while inactive instead of with the fade. * (Useful for devices where the fade can be expensive if overdone)" />
      <item value="* This value used used with the {@link #setRepeatCount(int)} property to repeat * the animation indefinitely." />
      <item value="REVERSE" />
      <item value="// Dynamic width, so we have no choice but to request a new // view layout with a new text layout." />
      <item value="// We lose: the height has changed and we have a dynamic height. // Request a new view layout using our new text layout." />
      <item value="* Check whether entirely new text requires a new view layout * or merely a new text layout." />
      <item value="forever" />
      <item value="unknown" />
      <item value="Bubble" />
      <item value="Eefect" />
      <item value="* &lt;p&gt;Instead of providing a media notification that is completely custom, a developer can set * this style and still obtain system decorations like the notification header with the expand * affordance and actions." />
      <item value="/** Subscriber priority to influence the order of event delivery. * Within the same delivery thread ({@link ThreadMode}), higher priority subscribers will receive events before * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of * delivery among subscribers with different {@link ThreadMode}s! */" />
      <item value="* If true, delivers the most recent sticky event (posted with * {@link EventBus#postSticky(Object)}) to this subscriber (if event available)." />
      <item value="primitive" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="496" />
        <entry key="ENGLISH" value="497" />
        <entry key="GERMAN" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="MARATHI" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="GREEK" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="4b8c0dd3e2395c8d" />
      </youdao-translate>
    </option>
  </component>
</application>