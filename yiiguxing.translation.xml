<application>
  <component name="AppStorage">
    <histories>
      <item value="Returns the int descriptor. It's highly unlikely you should be calling this. Please discuss * your needs with a libcore maintainer before using this method. * @hide internal use only" />
      <item value="Instances of the file descriptor class serve as an opaque handle * to the underlying machine-specific structure representing an open * file, an open socket, or another source or sink of bytes. The * main practical use for a file descriptor is to create a * &lt;code&gt;FileInputStream&lt;/code&gt; or &lt;code&gt;FileOutputStream&lt;/code&gt; to * contain it." />
      <item value="* Adds the given transport type to this {@code NetworkCapability} instance. * Multiple transports may be applied sequentially. Note that when searching * for a network to satisfy a request, any listed in the request will satisfy the request. * For example {@code TRANSPORT_WIFI} and {@code TRANSPORT_ETHERNET} added to a * {@code NetworkCapabilities} would cause either a Wi-Fi network or an Ethernet network * to be selected. This is logically different than * {@code NetworkCapabilities.NET_CAPABILITY_*} listed above. *" />
      <item value="* Adds the given transport requirement to this builder. These represent * the set of allowed transports for the request. Only networks using one * of these transports will satisfy the request. If no particular transports * are required, none should be specified here. See {@link NetworkCapabilities} * for {@code TRANSPORT_*} definitions. *" />
      <item value="Indicates that this network is available for general use. If this is not set * applications should not attempt to communicate on this network. Note that this * is simply informative and not enforcement - enforcement is handled via other means. * Set by default." />
      <item value="NET CAPABILITY NOT RESTRICTED" />
      <item value="Indicates this is a network that has the ability to reach a Wi-Fi direct * peer." />
      <item value="Similarly if an application * needs an unmetered network for a bulk transfer it can specify that rather than assuming * all cellular based connections are metered and all Wi-Fi based connections are not. */" />
      <item value="Rather than indicate a need for Wi-Fi because an application * needs high bandwidth and risk obsolescence when a new, fast network appears (like LTE), * the application should specify it needs high bandwidth." />
      <item value="Rather than indicate a need for" />
      <item value="Rather than indicate a need for Wi-Fi because an application * needs high bandwidth and risk obsolescence when a new, f" />
      <item value="satisfy" />
      <item value="represent" />
      <item value="capability" />
      <item value="* Indicates that this network should be able to reach the internet." />
      <item value="SPIN INDETERMINATE" />
      <item value="is Satation" />
      <item value="accidentally" />
      <item value="unmetered" />
      <item value="NET CAPABILITY NOT METERED" />
      <item value="METERED" />
      <item value="INTERNET" />
      <item value="* Indicates this network uses a Cellular transport." />
      <item value="TRANSPORT CELLULAR" />
      <item value="NET_CAPABILITY_MMS, NET_CAPABILITY_SUPL, NET_CAPABILITY_DUN, NET_CAPABILITY_FOTA, NET_CAPABILITY_IMS, NET_CAPABILITY_CBS, NET_CAPABILITY_WIFI_P2P, NET_CAPABILITY_IA, NET_CAPABILITY_RCS, NET_CAPABILITY_XCAP, NET_CAPABILITY_EIMS, NET_CAPABILITY_NOT_METERED, NET_CAPABILITY_INTERNET, NET_CAPABILITY_NOT_RESTRICTED, NET_CAPABILITY_TRUSTED, NET_CAPABILITY_NOT_VPN, NET_CAPABILITY_VALIDATED, NET_CAPABILITY_CAPTIVE_PORTAL, NET_CAPABILITY_NOT_ROAMING, NET_CAPABILITY_FOREGROUND, NET_CAPABILITY_NOT_CONGESTED, NET_CAPABILITY_NOT_SUSPENDED, NET_CAPABILITY_OEM_PAID," />
      <item value="* * Tells the underlying networking system that the caller wants to * begin using the named feature. The interpretation of {@code feature} * is completely up to each networking implementation. *" />
      <item value="/** * Binds the current process to {@code network}. All Sockets created in the future * (and not explicitly bound via a bound SocketFactory from * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to * {@code network}. All host name resolutions will be limited to {@code network} as well. * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to * work and all host name resolutions will fail. This is by design so an application doesn't * accidentally use Sockets it thinks are still bound to a particular {@link Network}. * To clear binding pass {@code null} for {@code network}. Using individually bound * Sockets created by Network.getSocketFactory().createSocket() and * performing network-specific host name resolutions via * {@link Network#getAllByName Network.getAllByName} is preferred to calling * {@code setProcessDefaultNetwork}. * * @param network The {@link Network} to bind the current process to, or {@code null} to clear * the current binding. * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid. * @deprecated This function can throw {@link IllegalStateException}. Use * {@link #bindProcessToNetwork} instead. {@code bindProcessToNetwork} * is a direct replacement." />
      <item value="reply" />
      <item value="scrap Or Recycle View" />
      <item value="other views that were previously recycled." />
      <item value="This ViewHolder should not be recycled. This flag is set via setIsRecyclable() * and is intended to keep views around during animations." />
      <item value="This ViewHolder points at data that represents an item previously removed from the * data set. Its view may still be used for things like outgoing animations. */" />
      <item value="This ViewHolder's data is invalid. The identity implied by mPosition and mItemId * are not to be trusted and may no longer match the item view type. * This ViewHolder must be fully rebound to different data." />
      <item value="The data this ViewHolder's view reflects is stale and needs to be rebound * by the adapter. mPosition and mItemId are consistent." />
      <item value="This ViewHolder has been bound to a position; mPosition, mItemId and mItemViewType * are all valid. */" />
      <item value="/ This is very ugly but the only place we can grab this information // before the View is rebound and returned to the LayoutManager for post layout ops. // We don't need this in pre-layout since the VH is not updated by the LM." />
      <item value="try Get View Holder For Position By Deadline" />
      <item value="Returns the value of the given calendar field. In lenient mode, * all calendar fields are normalized. In non-lenient mode, all * calendar fields are validated and this method throws an * exception if any calendar fields have out-of-range values. The * normalization and validation are handled by the * {@link #complete()} method, which process is calendar * system dependent." />
      <item value="merge" />
      <item value="Left edge, with item decoration insets included" />
      <item value="Lay out the given child view within the RecyclerView using coordinates that * include any current {@link ItemDecoration ItemDecorations}. *" />
      <item value="&gt;LayoutManagers should prefer working in sizes and coordinates that include * item decoration insets whenever possible. This allows the LayoutManager to effectively * ignore decoration insets within measurement and layout code. See the following * methods:&lt;/p&gt;" />
      <item value="// we need i to calculate the real offset of current view" />
      <item value="Temporarily detach and scrap all currently attached child views. Views will be scrapped * into the given Recycler. The Recycler may prefer to reuse scrap views before * other views that were previously recycled." />
      <item value="Returns the space occupied by this View in the perpendicular orientation including * decorations and margins. *" />
      <item value="m Decorated Measurement In Other" />
      <item value="* The offset of property which will change while scrolling" />
      <item value="//make sure properties are correct while measure more than once" />
      <item value="get Decorated Measured Height" />
      <item value="dry Run" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="78" />
        <entry key="ENGLISH" value="79" />
        <entry key="ROMANIAN" value="1" />
        <entry key="MARATHI" value="1" />
      </map>
    </option>
  </component>
</application>