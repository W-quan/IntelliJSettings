<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="756" />
    <option name="newTranslationDialogY" value="-596" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="tv money sign" />
      <item value="Throw Bottle Used Up Dialog" />
      <item value="tv signed days" />
      <item value="tv signed in days" />
      <item value="tv sign in days" />
      <item value="tv sign days" />
      <item value="已连续签到1天，继续加油哦！" />
      <item value="继续加油哦" />
      <item value="source Compatibility" />
      <item value="set Immediate" />
      <item value="frequent" />
      <item value="subsequent" />
      <item value="frequent exit will affect subsequent matches well" />
      <item value="频繁退出会影响后续匹配哦" />
      <item value="When stack from bottom is set to true, the list fills its content starting from the bottom of the view." />
      <item value="A scaling factor for fonts displayed on the display. This is the same as {@link density}, except that it may be adjusted in smaller increments at runtime based on a user preference for the font size." />
      <item value="Finds the node starting at root p with the given hash and key. The kc argument caches comparableClassFor(key) upon first use comparing keys." />
      <item value="Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced." />
      <item value="factor" />
      <item value="The table, initialized on first use, and resized as necessary. When allocated, length is always a power of two. (We also tolerate length zero in some operations to allow bootstrapping mechanics that are currently not needed.)" />
      <item value="spreads" />
      <item value="The load factor used when none specified in constructor." />
      <item value="The maximum capacity, used if a higher value is implicitly specified by either of the constructors with arguments. MUST be a power of two &lt;= 1&lt;&lt;30." />
      <item value="The default initial capacity - MUST be a power of two." />
      <item value="The concurrent-programming-like SSA-based coding style helps avoid aliasing errors amid all of the twisty pointer operations." />
      <item value="The use and transitions among plain vs tree modes is complicated by the existence of subclass LinkedHashMap. See below for hook methods defined to be invoked upon insertion, removal and access that allow LinkedHashMap internals to otherwise remain independent of these mechanics. (This also requires that a map instance be passed to some utility methods that may create new nodes.)" />
      <item value="When bin lists are treeified, split, or untreeified, we keep them in the same relative accesstraversal order (i.e., field Node.next) to better preserve locality, and to slightly simplify handling of splits and traversals that invoke iterator.remove. When using comparators on insertion, to keep a total ordering (or as close as is required here) across rebalancings, we compare classes and identityHashCodes as tie-breakers." />
      <item value="All applicable internal methods accept a hash code as an argument (as normally supplied from a public method), allowing them to call each other without recomputing user hashCodes. Most internal methods also accept a &quot;tab&quot; argument, that is normally the current table, but may be a new or old one when resizing or converting." />
      <item value="The root of a tree bin is normally its first node. However, sometimes (currently only upon Iterator.remove), the root might be elsewhere, but can be recovered following parent links (method TreeNode.root())." />
      <item value="Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (http:en.wikipedia.orgwikiPoisson_distribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) pow(0.5, k) factorial(k)). The first values are:" />
      <item value="more: less than 1 in ten million" />
      <item value="In usages with well-distributed user hashCodes, tree bins are rarely used." />
      <item value="And when they become too small (due to removal or resizing) they are converted back to plain bins." />
      <item value="Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD)." />
      <item value="Thus, performance degrades gracefully under accidental or malicious usages in which hashCode() methods return values that are poorly distributed, as well as those in which many keys share a hashCode, so long as they are also Comparable. (If neither of these apply, we may waste about a factor of two in time and space compared to taking no precautions. But the only known cases stem from poor user programming practices that are already so slow that this makes little difference.)" />
      <item value="The added complexity of tree bins is worthwhile in providing worst-case O(log n) operations when keys either have distinct hashes or are orderable" />
      <item value="(We conservatively check generic types via reflection to validate this -- see method comparableClassFor)." />
      <item value="Tree bins (i.e., bins whose elements are all TreeNodes) are ordered primarily by hashCode, but in the case of ties, if two elements are of the same &quot;class C implements Comparable&lt;C&gt;&quot;, type then their compareTo method is used for ordering." />
      <item value="checking for existence of tree bins may be delayed in the course of table methods." />
      <item value="since the vast majority of bins in normal use are not overpopulated," />
      <item value="but additionally support faster lookup when overpopulated." />
      <item value="Bins of TreeNodes may be traversed and used like any others," />
      <item value="Bins" />
      <item value="Most methods try to use normal bins, but relay to TreeNode methods when applicable (simply by checking instanceof a node)." />
      <item value="bins" />
      <item value="This map usually acts as a binned (bucketed) hash table, but when bins get too large, they are transformed into bins of TreeNodes, each structured similarly to those in java.util.TreeMap" />
      <item value="This map usually acts as a binned (bucketed) hash table, but" />
      <item value="On Swipe" />
      <item value="Filters the success item of the Single via a predicate function and emitting it if the predicate returns true, completing otherwise." />
      <item value="a function that, when applied to the item emitted by each of the source Singles, results in an item that will be emitted by the resulting Single" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="635" />
        <entry key="ENGLISH" value="636" />
        <entry key="POLISH" value="1" />
        <entry key="GERMAN" value="2" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="4" />
        <entry key="MARATHI" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="GREEK" value="2" />
        <entry key="ITALIAN" value="2" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1628480653896" />
  </component>
  <component name="Settings">
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="4b8c0dd3e2395c8d" />
      </youdao-translate>
    </option>
  </component>
</application>