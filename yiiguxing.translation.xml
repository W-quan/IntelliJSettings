<application>
  <component name="AppStorage">
    <histories>
      <item value="is Relation With Owner" />
      <item value="abbreviate" />
      <item value="Maybe need cache" />
      <item value="Maybe support cache" />
      <item value="Interceptor" />
      <item value="Backgroud" />
      <item value="Provier" />
      <item value="accept" />
      <item value="RESPOND" />
      <item value="accect" />
      <item value="respone" />
      <item value="set Minimum Fraction Digits" />
      <item value="relation" />
      <item value="COUPLE" />
      <item value="CARD BROMANCE" />
      <item value="BROMANCE" />
      <item value="intimate Space" />
      <item value="courtship" />
      <item value="become student" />
      <item value="become teacher" />
      <item value="bestie" />
      <item value="闺蜜" />
      <item value="基友" />
      <item value="iv head wear" />
      <item value="wear" />
      <item value="iv wear" />
      <item value="level" />
      <item value="// BitmapFactory.Options out* variables are reset by most calls to decodeStream, successful or // otherwise, so capture here in case we log below." />
      <item value="// Once we've read the image header, we no longer need to allow the buffer to expand in // size. To avoid unnecessary allocations reading image data, we fix the mark limit so that it // is no larger than our current buffer size here. We need to do so immediately before // decoding the full image to avoid having our mark limit overridden by other calls to // mark and reset. See issue #225." />
      <item value="// If we failed to obtain the image dimensions, we may end up with an incorrectly sized Bitmap, // so we want to use a mutable Bitmap type. One way this can happen is if the image header is so // large (10mb+) that our attempt to use inJustDecodeBounds fails and we're forced to decode the // full size image." />
      <item value="* Checks to see whether or not a log for the specified tag is loggable at the specified level." />
      <item value="/** We want to switch from the disk cache service to the source executor. */" />
      <item value="INITIALIZE" />
      <item value="// When we're encoding we've already notified our callback and it isn't safe to do so again." />
      <item value="* Tries to intelligently choose a strategy based on the data source of the {@link" />
      <item value="/** Writes resources to disk after they've been decoded. */" />
      <item value="/** Writes retrieved data directly to the disk cache before it's decoded. */" />
      <item value="* &lt;p&gt;This value will not change over the lifetime of a Bitmap.&lt;/p&gt;" />
      <item value="* &lt;p&gt;This can be larger than the result of {@link #getByteCount()} if a bitmap is reused to * decode other bitmaps of smaller size, or by manual reconfiguration. See {@link * #reconfigure(int, int, Config)}, {@link #setWidth(int)}, {@link #setHeight(int)}, {@link * #setConfig(Bitmap.Config)}, and {@link BitmapFactory.Options#inBitmap * BitmapFactory.Options.inBitmap}. If a bitmap is not modified in this way, this value will be * the same as that returned by {@link #getByteCount()}.&lt;/p&gt; *" />
      <item value="* Returns the size of the allocated memory used to store this bitmap's pixels." />
      <item value="* &lt;p&gt;As of {@link android.os.Build.VERSION_CODES#KITKAT}, the result of this method can * no longer be used to determine memory usage of a bitmap. See {@link" />
      <item value="* Returns the minimum number of bytes that can be used to store this bitmap's pixels." />
      <item value="* Return the number of bytes between rows in the bitmap's pixels. Note that * this refers to the pixels as stored natively by the bitmap. If you call * getPixels() or setPixels(), then the pixels are uniformly treated as * 32bit values, packed according to the Color class." />
      <item value="* Used internally to set the containing binding for an included binding to this." />
      <item value="SHELF" />
      <item value="seek" />
      <item value="* If the View occupies multiple spans, span with the minimum index is returned." />
      <item value="If" />
      <item value="* Starting with RecyclerView &lt;b&gt;24.2.0&lt;/b&gt;, span indices are always indexed from position 0 * even if the layout is RTL. In a vertical GridLayoutManager, &lt;b&gt;leftmost&lt;/b&gt; span is span * 0 if the layout is &lt;b&gt;LTR&lt;/b&gt; and &lt;b&gt;rightmost&lt;/b&gt; span is span 0 if the layout is * &lt;b&gt;RTL&lt;/b&gt;. Prior to 24.2.0, it was the opposite which was conflicting with * {@link SpanSizeLookup#getSpanIndex(int, int)}." />
      <item value="useless" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="524" />
        <entry key="ENGLISH" value="525" />
        <entry key="GERMAN" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="MARATHI" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="GREEK" value="2" />
        <entry key="ITALIAN" value="2" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="4b8c0dd3e2395c8d" />
      </youdao-translate>
    </option>
  </component>
</application>